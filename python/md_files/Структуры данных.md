## Массив

Линейная структура данных, коллекция сходных по типу объектов. Хранится в смежных ячейках памяти, основан на системе индексов 0 - n, где n - количество элементов.

При объявлении заполняется значениями по умолчанию.

| Тип                | Значение по умолчанию |
| ------------------ | --------------------- |
| Численный примитив | 0                     |
| Символьный тип     | 0 (Символ NUL)        |
| Логический тип     | False                 |
| Оболочечный тип    | null                  |
| Объект                   |           null            |

Размер массива в байтах: sizeof(T) * n, где T - элемент, n - число элементов
Многомерный массив — Двумерный, трехмерный, или N-мерный

| Базовые операции | Сложность |
|:----------------:|:---------:|
|    Изменение     |   O(n)    |
|     Вставка      |   O(1)    |
|     Удаление     |   O(1)    |
|      Обход       |   O(n)    |
|      Поиск       |   O(n)    |

##### `Все они выполняются с помощью арифметики указателей.`
#### Особенности массива:

##### Плюсы:
+ Скорость доступа к данным
+ Обращение по индексу
+ Экономия памяти, если объем данных известен
##### Минусы:
- Фиксированный размер
- Перерасход памяти, если объем данных неизвестен
- Невозможность удалить данные без сдвига
- Массив нельзя закрыть для изменений

## Список

— Динамический массив, позволяет изменять свой размер в зависимости от объема поступивших данных
По сути, тот же самый массив с обслуживающими функциями для удаления, добавления элементов и т.д.

## [Односвязный список](https://nuancesprog.ru/p/15420/)

Последовательность объектов, которые содержат данные + указатель на следующий элемент списка. Он равен NULL в случае последнего элемента.

Содержит элемент ссылки, называемой head (первой).

#### Базовые операции:
- **Вставка**
	- В конец: 
		Значение указателя у последнего элемента меняется с NULL на указатель на нужный элемент
		
		Сложность O(n)
		```
		LIST ... -> A -> B 
		X - новый элемент в конце

		B.next = X
		```
	- В начало: 
		Значение указателя нового элемента указывает на первый элемент
		Сложность O(1)
		```
		LIST A -> B -> ...
		X - новый элемент в начале
		
		head = X
		X.next = A
		```
	- В середину:
		Ссылки между двумя элементами обновляются чтобы поочередно указывать на новый элемент:
		
		Сложность варьируется от O(1) в начале и O(n) в конце. Поиск занимает O(n) в худшем случае.
		```
		LIST ... -> A -> B -> ...
		X - новый элемент между A и B

		A.next = X
		X.next = B
		```
- **Удаление**
	
	Поиском находим элемент, который нужно удалить, если это не первый элемент. Меняем указатели так, что предыдущий от него узел должен указывать на следующий от него. После этого удаляем ненужную ноду.
	
	Сложность варьируется от O(1) в начале и O(n) в конце. Поиск занимает O(n) в худшем случае.
	
```
LIST  A -> B -> C
Нужно удалить B

A.next = C
B.next = NULL
B.value = NULL
```

## [Двусвязный список](https://nuancesprog.ru/p/15493/)

Последовательность объектов, которые содержат поле с данными + указатели на предыдущий и следующий элемент. 
NULL  в случае ссылки **next** у последнего и ссылки **prev** у первого элементов.

#### Базовые операции:

- **Вставка**
	- **В конец**:
		Значение **next** у последнего элемента меняется с NULL на указатель на нужный элемент.
		Значение **prev** у нового элемента указывает на прошлый последний элемент. **next** у него становится NULL.
		Обозначаем новый узел как **last**
		
		Сложность O(1)
		```
		LIST ... <-> A <-> B
		X - новый элемент

		X.prev = B
		B.next = X
		X.next = NULL
		last = X
		```
	- **В начало**:
		Значение указателя **next** нового элемента указывает на первый элемент. 
		Указатель **prev** первого элемента вместо NULL указывает на новый элемент.
		Обозначаем новый узел как **head**
		
		Сложность O(1)
		```
		LIST A <-> B <-> ... 
		X - новый элемент

		A.prev = x
		x.prev = NULL
		x.next = A
		head = X
		```

	- **Между элементами**:
		Ссылки между двумя элементами обновляются чтобы поочередно указывать на новый элемент:

		Сложность O(n) в худшем случае
		```
		LIST ... <-> A <-> B <-> ... 
		X - новый элемент
		
		A.next = x
		X.prev = a
		B.prev = x
		X.next = b
		```

- **Удаление**:
	Ищем нужный для удаления элемент, если это не первый и не последний.
	Если нужно сохранить/вернуть ссылку на него, создаем временный указатель.
	Меняем указатели соседних элементов.

	Сложность O(1) для начала и конца, O(n) для середины
	```
	LIST ... <-> A <-> B <-> C -> ...
	B нужно удалить

	B.next = NULL
	B.prev = NULL
	A.next = C
	C.prev = A
	```

#### Особенности операций со списками: 

|                **Плюсы**                |                  **Минусы**                  |
|:---------------------------------------:|:--------------------------------------------:|
|   Легкость добавления новых элементов   | Долгий доступ к информации в середине списка |
| Любые типы данных, даже такие же списки | Расход памяти из-за метаинформации (ссылок)  |
|        Готовые методы управления        |                                              |                                        |                                              |

## Список с пропусками

Структура, которая состоит из слоев. В самом низу — сортированный связный список. Более высокие уровни содержат меньшее число элементов, которые указывают на такие же в оригинальном списке.

![[SKIP LIST PNG.png]]

#### Особенности работы списка с пропусками:

>Техника подбрасывания монет используется для случайного определения количества слоев, которые элемент будет занимать в списке пропусков. При вставке нового элемента генерируется случайное число, которое сравнивается с заданным пороговым значением. Если случайное число меньше порогового значения, элемент вставляется в следующий слой. Этот процесс повторяется до тех пор, пока случайное число не превысит пороговое значение, после чего элемент вставляется в нижний слой. Техника подбрасывания монеты - это то, что придает спискам пропусков их вероятностный характер и обеспечивает их эффективную среднюю временную сложность.

**Плюсы**:

- Надежность
- Быстрое добавление новых элементов
- Быстрый поиск
- Простота реализации по сравнению с хэш-таблицей и бинарным деревом поиска
- Сложность всех операций  — O(log n)

**Минусы**:

- Больший расход памяти по сравнению со сбалансированным деревом
- Обратный поиск не разрешен

##### Реализации:

**Поиска** 
Начинаем с верхнего списка, сравнивая каждый элемент с заданным. Если он меньше, спускаемся ниже. Если равен - возвращаем результат поиска. 

**Удаления**
Ищем элемент для удаления и удаляем его из всех слоев

**Вставки**
Сначала подсчитывается, сколько слоев будет занимать элемент. 
Для вставки начинаем с верхнего списка, если элемент меньше целевого, спускаемся ниже и вставляем в нижний список.



## [Стек](https://www.geeksforgeeks.org/introduction-to-stack-data-structure-and-algorithm-tutorials/)

Линейная структура данных по принципу LIFO (Last In - First Out)
Нужно обновлять указатель только на последний элемент.

#### Основные методы стека (У всех сложность O(1)):

- push(item) — Добавить элемент сверху:
```
if stack is full:
	return
else:
	top ++
	stack[top] = value
```

- pop() — Удалить последний элемент и вернуть его:

```

if stack is Empty:
	return
else:
	value = stack[top]
	top --
	return value
```
- peek() — Вернуть последний элемент без удаления:
```

if stack is Empty:
	return
else:
	return stack[top]
```
- IsEmpty() — проверка на пустоту. **False** если есть хоть 1 элемент:
```

if top < 1:
	return True
else:
	return False
```
- size() — Размер стека
```
return top
```
- IsFull() — Проверка на заполненность. True если полон.
```
return sizeof(stack) = top
```

#### Особенности операций со стеком:

|                  Плюсы                  |                             Минусы                              |
|:---------------------------------------:|:---------------------------------------------------------------:|
| Эффективный расход памяти как у массива |      Ограниченный размер, отсюда возможность переполнения       |
|       Быстрый доступ к элементам        |                       Нерандомный доступ                        |
|         Простота имплементации          | Возможная фрагментация памяти из-за частого удаления/добавления |

#### Сценарии использования стека: 

- Функции отмены - повтора действий:
	- Каждый раз, когда выполняется действие, оно помещается в стек. Чтобы отменить действие, извлекается верхний элемент стека и выполняется обратная операция.
- История браузера:
	- Каждый раз, когда вы посещаете новую страницу, URL-адрес помещается в стек, а когда вы нажимаете кнопку "Назад", предыдущий URL-адрес извлекается из стека.
- Проверка сбалансированных двойных символов (круглые скобки, кавычки и т.д):
	- Открывающая скобка помещается в стек, а закрывающая скобка извлекается из стека. Если в конце выражения стек пуст, круглые скобки сбалансированы.
- Алгоритмы обратного отслеживания:
	- Алгоритм обратного отслеживания использует стеки для отслеживания состояний процесса решения проблем. Текущее состояние помещается в стек, а когда алгоритм возвращается к исходному состоянию, предыдущее состояние извлекается из стека.
## [Очередь](https://www.geeksforgeeks.org/queue-data-structure/)

— Линейная структура данных по принципу FIFO (First In First Out)

Способы реализации:
>- С помощью массива с ограниченным числом элементов. (Последовательная аллокация)
>- С помощью связанного списка, тогда количество элементов неограничено)

#### Виды очереди:

- Простая очередь
- Круговая очередь:
	- Последний элемент находится рядом с первым. Подразумевает оптимальный расход памяти (Если на какой-то позиции нет элемента, он может быть туда добавлен)
- Приоритетная очередь:
	- Приоритет является свойством (Приоритет может быть у наибольшего элемента, очередь будет выстроена в порядке убывания или наоборот)
- Очередь с двойным завершением:
	- Элементы могут быть вставлены / удалены с обоих концов. Такая очередь не подчиняется принципу FIFO
#### Сценарии использования очереди:

- Многозадачность (мультипрограммирование):
	- Выполнение нескольких операций (задач) на одном процессоре реализовано через очередь
- Почтовая очередь:
	- Каталог, в котором хранятся данные и который управляет файлами для почтовых сообщений
- Планирование заданий:
	- Когда программе требуется последовательно выполнить несколько операций, их можно хранить в очереди

#### Типы операций:

- Enqueue(value) — Добавляем элемент в конец списка
- Dequeue(value) — Удаляем элемент из начала списка и возвращаем его
- front() — Возвращаем элемент в начале без удаления
- rear() — Возвращаем элемент в конце без удаления
- size() — Возвращаем размер очереди
- IsEmpty() — Проверка на пустоту. False при > 1 элемента

## [Хэш- таблица](https://www.geeksforgeeks.org/hash-table-data-structure/)

Объект, где данные помещаются в ассоциативный массив с помощью функции хэширования. Применяем функцию к значению элемента, делим без остатка на размер массива, получаем позицию такого элемента.

Коэффициент заполнения хеш-таблицы - количество хранимых элементов массива, деленное на число возможных значений хеш-функции. Является важным параметром, от которого зависит среднее время выполнения операций.

Коллизия — "столкновение" двух элементов. Возникает, когда хэш-функция возвращает одно и то же значение для двух элементов.

#### Решение коллизий:
- Метод двойного хэширования:

	- Одна хеш-функция (при входе g) будет возвращать натуральное число s, которое будет для нас начальным. То есть первое, что мы сделаем, попробуем поставить элемент g на позицию s в нашем массиве. Но что, если это место уже занято? Именно здесь нам пригодится вторая хеш-функция, которая будет возвращать t — шаг, с которым мы будем в дальнейшем искать место, куда бы поставить элемент g. Мы будем рассматривать сначала элемент s, потом s + t, затем s + 2*t* и т.д. Естественно, чтобы не выйти за границы массива, мы обязаны смотреть на номер элемента по модулю (остатку от деления на размер массива).

Недостатки метода двойного хэширования:
- Предполагает фиксированный размер таблицы

- Метод цепочек (связывание):
	- Организация связанного списка из всех элементов, которые вызывают коллизию. Включение очередного элемента включается в конец списка.

#### Сценарии использования хэш-таблиц

- Индескация и поиск информации в больших объемах данных. Поисковая система может использовать хэш-таблицу для хранения веб-страниц, которые она проиндексировала.
- Данные обычно кэшируются в памяти с помощью хэш-таблиц, что обеспечивает быстрый доступ к часто используемой информации.
- В криптографии для создания цифровых подписей, проверки данных и гарантии целостности данных.
- Хэш-таблицы можно использовать для реализации индексов базы данных, обеспечивая быстрый доступ к данным на основе значений ключа.
#### Типы операций:

 - Удаление:
	 - Ненужные элементы удаляются логически, помечаются "deleted". Когда количество таких элементов доходит до 50% от таблицы, делаем Rehash. 

- Resize:
	- То же самое, что и увеличение динамического массива (создаем новый массив, копируем все элементы, удаляем старый массив). Обычно увеличиваем вдвое.

- Rehash:
	- Пересчитываем новые хэши для каждого элемента, не помеченного "deleted", переносим в новую таблицу, старую удаляем. 

- Поиск:
	- Прогоняем значение через функцию хэширования, делим на размер массива, получаем номер ячейки где располагается элемент. Если решали коллизию методом цепочек, пробегаем по внутреннему списку.

- Вставка 
	- Именно тут проверяем на необходимость Resize (если ) или Rehash. 
## [[BIG O PNG.png|Сложность операций для структур данных]]


