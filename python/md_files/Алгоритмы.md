## Поиска:

#### Линейный O(n):
Пробегаем по всем элементам, сравнивая с целевым значением. Самый неэффективный, сложность О(n).

#### Бинарный O(log(n)):
Работает только с отсортированным массивом. 
- Разделяем список на два. 
- Если догадка меньше цели, ищем в большей половине списка.
- Если больше, ищем в малой половине списка.
- Если равна, возвращаем ее.

```python
def binary_search(list, item):
	low = 0
	high = len(list) - 1
	while low <= high:
		mid = (low + high) / 2
		guess = list[mid]
		if guess == item:
			return mid
		elif guess > item:
			high = mid -1
		else:
			low = mid + 1
	return None
```

## Сортировки:

#### Пузырьком О(n^2)
Проходим по массиву, сравнивая два элемента. Если левый больше, меняем их местами. Повторяем до тех пор, пока массив не отсортирован. Большой элемент "всплывает вверх"

```python
def swap(a,b):
	a = temp
	a = b
	b = temp
	
def bubble_sort(arr):
	length = len(arr)
	for i in range(length-1):
		for j in range(length - i - 1)
		if arr[i] > arr[i+1]:
			swap(arr[i], arr[i+1])
		
```

#### Выбором О(n^2):

Находим самый большой элемент в массиве, добавляем его в новый список и удаляем из старого.

```python
def selection_sort(arr):
	length = len(arr)
	for i in range(length - j):
	
	current_min = arr[i]
	min_index = i
	#найти минимальный элемент
		for j in range(i , length):
			if arr[j] < current_min:
				current_min = arr[j]
				min_index = j
				
		swap(arr[i],arr[j])
```

#### Вставками O(n^2):

